#Active Record

1.Active Record是MVC中的M，处理数据和业务逻辑，负责创建和使用需要持久存入数据库中的数据。是一种对象关系映射(ORM)系统
 1.1ORM把程序中的对象和关系型数据库中的数据表连接起来,程序中对象的属性和对象间的关系可以通过一种简单的方法从数据库获取,无需编写SQL语句,也不过度依赖特定的数据库种类
 1.2Active Record用作ORM框架提供的功能
  1).表示Model和其中的数据
  2).表示Model间的关系
  3).通过相关联的Model表示继承关系
  4).持久存入数据库前,验证Model
  5).以面向对象的方式处理数据库操作

2.Active Record中"多约定少配置"原则
 2.1命名约定：查找Model与数据表的映射关系，Rails把Model类名转换为复数（Article->articles），然后查找对应的数据表
 2.2模式约定：对数据表中的字段命名约定
	1).外键：使用singularized_table_name_id命名，创建模型关联后（Comment），Active Record会查找这个字段（article_id）
	2).主键：数据迁移时会字段创建使用整数字段id作为表的主键
	3).created_at：创建记录时，自动设为当前时间戳
	4).updated_at：更新记录时，自动设为当前时间戳
	5).lock_version：在模型中添加乐观锁定功能
	6).type：让模型使用单表继承
	7).(association_name)_type：多态关联的类型
	8).(table_name)_count：缓存关联对象的数量

3.CRUD:读写数据
 3.1创建：new/create方法会实例化一个对象，create方法直接将该对象对应的记录存入数据库，new方法需要额外调用save方法
 3.2读取：article=Article.all/first/find_by(id:1)/where(title:'xxx').order('created_at DESC')....
 3.3更新：article=Article.find_by(title:'xxx') article.title='xx' article.save
		  article=Article.find_by(title:'xxx') article.update(title:'xx')
		  Article.update_all "title=xx" #批量更新
 3.4删除：article=Article.find_by(title:'xxx') article.destroy

****************************************************************************************************
4.数据验证：数据存入数据库前验证对象的状态
	validates :title,presence:true  ...可以检查属性值是否为空/唯一/数据库中是否存在，调用create、save、update时验证失败会返回false
	*在模型中做验证是最有保障的，只有通过验证的数据才存入数据库
	1).valid?方法会触发数据验证，如果对象上没有错误，就返回true，否则返回false。invalid?相反
	2).验证结束后，所有发现的错误都可以通过实例方法errors.messages获取，该方法返回一个错误集合。
	3).验证结束后，使用errors[:属性名]验证对象某个属性是否出错
 4.2帮助方法
  所有的帮助方法都可指定:on和:message选项，指定何时做验证，以及验证失败后向errors集合添加什么消息。:on选项的可选值是:create和:update。每个帮助函数都有默认的错误消息，如果没有通过:message选项指定，则使用默认值
  4.2.1 acceptance:检查表单提交时，要求用户接受程序的服务条款等，不存入数据库，也可以指定:accept选项决定接受什么值。validates :xx, acceptance: { accept: 'yes' }
  4.2.2 validates_associated：模型间有关联，也需要验证关联的模型对象(不要在关联模型的两端都使用此方法，这样会生成一个循环)
  4.2.3 confirmation：验证2个文本字段的值是否完全相同。它会创建一个虚拟属性:xx_confirmation，但只有其值不为nil时才会做这个验证，要在确认属性加上存在性验证validates :xx_confirmation, presence: true
  4.2.4 exclusion/inclusion：检查属性的值是否不在/在指定的集合中。要指定:in选项，设置哪些值不能/能作为属性的值。:in 选项有个别名 :with，作用相同。
  4.2.5 format：检查属性的值是否匹配:with选项指定的正则表达式
  4.2.6 length：检查属性值的长度。
  4.2.7 numericality：检查属性值是否值包含数字。
  4.2.8 presence/absence：内部调用blank?/present?方法检查属性值是否为非空值/空值。
  4.2.9 uniqueness：检查属性值是否唯一。会在模型对应的数据表中执行一个SQL查询，检查现有的记录中该字段是否已经出现过相同的值。:scope选项指定其他属性，约束唯一性验证。:case_sensitive选项指定唯一性验证是否区分大小写，默认值为true
  4.2.10 validates_with 把记录交给其他类做验证，参数是一个或一组类
  4.2.11 validates_each 把属性值传入代码库做验证，没有预先定义验证的方式，需要在代码库中定义验证方式。要验证的每个属性都会传入块中做验证。代码块的参数是记录record，属性名attr，属性值value
 4.3常用的验证选项
  4.3.1 :allow_nil 验证的值为 nil 就会跳过验证
  4.3.2 :aloww_blank 验证的值为空（调用 blank? 方法，例如 nil 或空字符串），就会跳过验证。
  4.3.3 :message 验证失败，会把:message选项指定的字符串添加到errors集合中。如果没指定这个选项，Active Record 会使用各种验证帮助方法的默认错误消息
  4.3.4 :on指定什么时候做验证。内建的验证帮助方法默认都在保存时（新建记录或更新记录）做验证。可以使用on: :create，指定只在创建记录时做验证；或者使用on: :update，指定只在更新记录时做验证。
 4.4严格验证
 	validates :name, presence: { strict: true }.失败后会抛出 ActiveModel::StrictValidationFailed 异常
 	validates :token, presence: true, uniqueness: true, strict: TokenGenerationException #指定抛出异常
 4.5条件验证
  条件可通过:if和:unless选项指定，这两个选项的值可以是Symbol、字符串、Proc或数组。
  4.5.1指定Symbol
  validates :xx, presence: true, if: :xxx?在验证之前执行对应的xxx?方法
  4.5.2指定字符串
  validates :xx, presence:true, if: "xxx.nil?" 必须是Ruby代码，传入eval方法中执行。当字符串表示的条件非常短时才应该使用这种形式。
  4.5.3指定Proc
  validates :password, confirmation: true, unless: Proc.new { |a| a.password.blank? }
  使用Proc对象可以在行间编写条件，不用定义额外的方法。这种形式最适合用在一行代码能表示的条件上。
  4.5.4条件组合：有时同一个条件会用在多个验证上，这时可以使用with_options方法
  with_options if: :is_admin? do |admin|
    admin.validates :password, length: { minimum: 10 }
    admin.validates :email, presence: true
  end
  4.5.5联合条件
  当多个条件规定验证是否应该执行时，可以使用数组。而且同一个验证可以同时指定:if和:unless选项。
  validates :mouse, presence: true,
                    if: ["market.retail?", :desktop?]
                    unless: Proc.new { |c| c.trackpad.present? }
 5.自定义验证方式
  5.1自定义验证使用的类
  	1).自定义的验证类继承自ActiveModel::Validator，必须实现validate方法，传入的参数是要验证的记录，然后验证这个记录是否合法。自定义的验证类通过validates_with方法调用。
  	2).自定义的验证类中验证单个属性，最简单的方法是集成ActiveModel::EachValidator类。此时自定义的验证类中要实现validate_each方法。这个方法接受三个参数：记录，属性名和属性值。
  5.2自定义验证使用的方法
  	使用类方法validate注册这些方法，传入自定义验证方法名的Symbol形式。
  	validate :active_customer, on: :create
    def active_customer
    	errors.add(:customer_id, "is not active") unless customer.active?
    end
  6.处理验证错误
   6.1 errors
   	实例.errors.messages 返回结果其键是每个属性的名字，值是一个数组，包含错误消息字符串。
   	实例.errors.full_messages/to_a 以最终显示给用户的形式显示错误消息。这些错误消息的前面都会加上字段名可读形式
   6.2 errors[]
   	实例.errors[:属性名] 返回该属性所有错误消息字符串组成的数组，每个字符串表示一个错误消息。如果字段上没有错误，则返回空数组
   6.3 errors.add
   	errors.add(:属性名, "xxx")/errors[:属性名]="xxx" 手动添加某属性的错误消息。
   6.4 errors[:base]
   	错误消息添加到整个对象上，而不是针对某个属性。errors[:base]是个数组，可以添加字符串作为错误消息。
   	errors[:base] << "This is invalid because ..."
   6.5 errors.clear 清除errors集合中的所有错误消息
   6.6 errors.size 返回对象上错误消息的总数
  7.在视图中显示验证错误
  <% if @article.errors.any? %>
  	<div id="error_explanation">
    <h2><%= pluralize(@article.errors.count, "error") %> prohibited this article from being saved</h2>
    <ul>
    <% @article.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
    </div>
  <% end %>
**************************************************************************************************
5.回调：是在对象生命周期的特定时刻执行的方法，其状态(创建/保存/更新/销毁/验证等)改变之前或之后触发指定的逻辑操作。
   5.1
    validates :login, :email, presence: true
    before_validation :ensure_login_has_a_value，on: :create #或on: [ :create, :update ]指定只在对象生命周期的特定事件发生时执行,如果不设置:on选项，每个操作都会触发回调。
    before_create do  #接受一个代码块。如果操作可以使用一行代码表述，可以考虑使用代码块形式。
     self.name = login.capitalize if name.blank?
    end
    protected
     def ensure_login_has_a_value
      if login.nil?
        self.login = email unless email.blank?
      end
     end
	*使用回调之前，要先注册。回调方法的定义和普通的方法一样，然后使用类方法注册。一般都把回调方法定义为受保护的方法或私有方法。如果定义成公共方法，回调就可以在模型外部调用，违背了对象封装原则。
   5.2可用的回调
    before_validation、after_validation
    before_save、around_save、after_save
    before_create、around_create、after_create
    before_update、around_update、after_update
    before_destroy、around_destroy、after_destroy
    *创建和更新对象时都会触发after_save，但不管注册的顺序，总在after_create和after_update之后执行。
    after_initialize 回调在对象初始化时执行，包括直接使用new方法初始化和从数据库中读取记录。不用直接重定义Active Record的initialize方法。
    after_find 回调在从数据库中读取记录时执行(all,first,find.find_by,find_by_*,find_by_*!,find_by_sql,last)
    after_touch 回调在触碰Active Record对象的touch方法时执行。可以搭配使用belongs_to :model, touch: true
   5.3执行回调
   	触发执行回调的方法：create、create!、decrement!、destroy、destroy!、destroy_all、increment!、save、save!、save(validate: false)、toggle!、update_attribute、update、update!、valid?
   5.4跳过回调
    跳过回调的方法：decrement、decrement_counter、delete、delete_all、increment、increment_counter、toggle、touch、update_column、update_columns、update_all、update_counters
   5.5终止执行
    在模型中注册回调后，回调会加入一个执行队列。这个队列中包含模型的数据验证，注册的回调，以及要执行的数据库操作。整个回调链包含在一个事务中。如果任何一个before_*回调方法返回false或抛出异常，整个回调链都会终止执行，撤销事务。而after_*回调只有抛出异常才能达到相同的效果。
   5.6条件回调(类似条件验证line60)
    在满足指定条件时再调用回调方法。条件通过:if和:unless选项指定，选项的值可以是Symbol、字符串、Proc或数组。:if选项指定什么时候调用回调。如果要指定何时不调用回调，使用:unless选项。
    1).使用Symbol：before_save :normalize_card_number, if: :paid_with_card?
    2).使用字符串（Ruby代码）：before_save :normalize_card_number, if: "paid_with_card?"
    3).使用Proc：before_save :normalize_card_number,if: Proc.new { |order| order.paid_with_card? }
    4).回调的多重条件：after_create :send_email_to_author,if: :author_wants_emails?,unless: Proc.new{|comment| comment.post.ignore_comments? }
   5.7回调类：回调方法可以在其他模型中重用，我们可以将其封装在类中。
   	class PictureFile < ActiveRecord::Base
  		after_destroy PictureFileCallbacks
	end
	class PictureFileCallbacks
  		def self.after_destroy(picture_file)
    		if File.exist?(picture_file.filepath)
      			File.delete(picture_file.filepath)
    		end
  		end
	end
   5.8事务回调：模型要和数据库事务之外的系统交互。
    数据库事务完成时触发：after_commit、after_rollback
    after_commit和after_rollback回调确保模型的创建、更新和销毁等操作在事务中完成。如果这两个回调抛出了异常，会被忽略，因此不会干扰其他回调。因此，如果回调可能抛出异常，就要做适当的补救和处理。

###################################################################################################
6.数据库迁移：按照时间顺序修改数据库的模式，rake之后数据表才会创建。回滚迁移，数据表会被删除
 6.1创建迁移
  6.1.1单独创建迁移 迁移名称是AddXxxToYyy或者RemoveXxxFromYyy格式，而且后面跟着字段和类型列表，迁移中会在yyys表中生成合适的add_column或remove_column语句
   rails generate migration CreateArticles 创建一个空的迁移(title:string创建一个有title字段的数据表articles)
   rails generate migration AddPartNumberToArticles part_number:string:index 在Articles表中创建一个新的字段part_number
   rails generate migration RemovePartNumberFromArticles part_number:string 移除articles表中part_number字段
  6.1.2模型生成器 rails generate model Article title:string text:text
  6.1.3支持的类型修饰符（在字段类型后面，可以在{}中添加的选项）
   1).limit：设置string/text/binary/integer类型字段的最大值
   2).precision：设置decimal类型字段的精度，即数字的位数
   3).scale：设置decimal类型字段小数点后的数字位数
   4).polymorphic：为belongs_to关联添加type字段
   5).null：是否允许该字段的值为null
   *price:decimal{5,2}生成的迁移是:decimal, precision: 5, scale: 2
 6.2编写迁移
  6.2.1创建数据表
   create_table方法会默认创建名为id的主键，通过:primary_key可以修改主键名，不想生成主键可以传入id:false，数字数据库的选项，可以在:options选择中使用SQL。options:"ENGINE=BLACKHOLE"会在创建数据表的SQL语句后面加上ENGINE=BLACKHOLE。（MySQL默认的选项是 ENGINE=InnoDB）
   create_table :articles do |t|
  		t.string :title,null:false #创建title字段,类型修饰符null不允许字段值为null
   end
  6.2.2创建联合数据表
  create_join_table :artices,:comments 会创建一个artices_comments的数据表，包含2个字段artice_id和comment_id,:null选项默认是false
  create_join_table :artices,:comments,table_name: :xxxxxx,column_options:{null:true} 指定数据库名称为xxxxxx，字段值可以为null
  create_join_table :artices, :comments do |t|
  		t.index :artice_id
  		t.index :comment_id
  end
  6.2.3修改数据表
  change_table修改现有的数据表
  change_table :articles do |t|
  		t.remove :title		#移除title字段
  		t.string :part_number	#创建part_number字段
  		t.index :part_number	#并建立索引
  		t.rename :text, :content #重命名text字段
  end
  6.2.4使用execute方法执行任意的sql语句
  Article.connection.execute('UPDATE `articles` SET `price`=`free` WHERE 1')
  6.2.5使用change方法
  change方法是最常用的方法，可以完成大多数指定的操作，在change方法中只能使用下面的方法，
  	add_column、add_index、add_reference、add_timestamps、create_table、create_join_table、drop_table（必须提供代码块）、drop_join_table（必须提供代码块）、remove_timestamps、rename_column、rename_index、remove_reference、rename_table
  6.2.6使用reversible方法指定运行和撤销复杂的迁移操作
  	确保操作是按顺序执行的
  6.2.7使用up和down方法
  	up方法定义要对数据库模式做哪些操作
  	down方法用于撤销这些操作
  	*撤销时最好按照添加的相反顺序进行
  6.2.8撤销之前的迁移
  	revert方法还可以接收一个块，定义撤销操作，可以撤销以前迁移的部分操作
  6.3运行迁移：rake db:migrate (VERSION=xxxx)，执行(xxxx时间戳之前)迁移中的change或up方法
   6.3.1回滚
   	rake db:rollback (STEP=3)/rake db:migrate:redo (STEP=3) 回滚前1次(前3次)的迁移，撤销change中操作或执行down方法。
   6.3.2搭建数据库
   	rake db:setup 创建数据库，加载模式，并填充种子数据
   6.3.3重建数据库
   	rake db:reset/rake db:drop db:setup 删除数据库然后重建
   6.3.4运行指定的迁移
   	rake db:migrate:up(down) VERSION=xxxx
   6.3.5在不同环境中运行迁移
   	rake db:migrate RAILS_ENV=xxx
   6.3.6修改运行迁移时的输出
   	rake db:migrate VERBOSE=boolean 是否输出迁移时的日志
   	suppress_messages 接受一个代码块，禁止代码块中所有操作的输出
   	say 接受一个消息字符串作为参数，将其输出。第二个参数是布尔值，指定输出结果是否缩进
   	say_with_time 输出文本，以及执行代码块中操作所用时间。如果代码块的返回结果是整数，会当做操作的记录数量
  6.4修改现有的迁移
  	必须先回滚迁移rake db:rollback，编辑迁移文件后rake db:migrate执行改正后的版本。
  6.5导出模式
   6.5.1模式文件的使用：即db/schema.rb文件，可用来快速查看 Active Record 中有哪些属性
   6.5.2导出的模式文件类型
   	config/application.rb 文件中的 config.active_record.schema_format 选项设置，可以是 :sql 或 :ruby
   6.5.3模式导出和版本控制
   	rake db:structure:dump导出sql格式的数据库结构，无数据
   	*导出的模式文件是数据库模式的可信源，强烈推荐将其纳入版本控制。
  6.6迁移和种子数据
  	Rails提供了“种子”功能，可以把初始化数据存入数据库。在db/seeds.rb文件中写一些Ruby代码，然后执行rake db:seed命令即可
###################################################################################################

7.Active Record关联



###################################################################################################

8.Active Record查询